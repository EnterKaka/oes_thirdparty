// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: blickfeld/common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_blickfeld_2fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_blickfeld_2fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "blickfeld/options.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_blickfeld_2fcommon_2eproto BF_DLLEXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct BF_DLLEXPORT TableStruct_blickfeld_2fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern BF_DLLEXPORT const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_blickfeld_2fcommon_2eproto;
namespace blickfeld {
namespace protocol {
class Constraint;
struct ConstraintDefaultTypeInternal;
BF_DLLEXPORT extern ConstraintDefaultTypeInternal _Constraint_default_instance_;
class Constraint_Constant;
struct Constraint_ConstantDefaultTypeInternal;
BF_DLLEXPORT extern Constraint_ConstantDefaultTypeInternal _Constraint_Constant_default_instance_;
class Constraint_Polynomial;
struct Constraint_PolynomialDefaultTypeInternal;
BF_DLLEXPORT extern Constraint_PolynomialDefaultTypeInternal _Constraint_Polynomial_default_instance_;
class Field;
struct FieldDefaultTypeInternal;
BF_DLLEXPORT extern FieldDefaultTypeInternal _Field_default_instance_;
class Field_Identifier;
struct Field_IdentifierDefaultTypeInternal;
BF_DLLEXPORT extern Field_IdentifierDefaultTypeInternal _Field_Identifier_default_instance_;
class HardwareModule;
struct HardwareModuleDefaultTypeInternal;
BF_DLLEXPORT extern HardwareModuleDefaultTypeInternal _HardwareModule_default_instance_;
class OptionalValueRange;
struct OptionalValueRangeDefaultTypeInternal;
BF_DLLEXPORT extern OptionalValueRangeDefaultTypeInternal _OptionalValueRange_default_instance_;
class SoftwareVersion;
struct SoftwareVersionDefaultTypeInternal;
BF_DLLEXPORT extern SoftwareVersionDefaultTypeInternal _SoftwareVersion_default_instance_;
class ValueRange;
struct ValueRangeDefaultTypeInternal;
BF_DLLEXPORT extern ValueRangeDefaultTypeInternal _ValueRange_default_instance_;
}  // namespace protocol
}  // namespace blickfeld
PROTOBUF_NAMESPACE_OPEN
template<> BF_DLLEXPORT ::blickfeld::protocol::Constraint* Arena::CreateMaybeMessage<::blickfeld::protocol::Constraint>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::Constraint_Constant* Arena::CreateMaybeMessage<::blickfeld::protocol::Constraint_Constant>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::Constraint_Polynomial* Arena::CreateMaybeMessage<::blickfeld::protocol::Constraint_Polynomial>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::Field* Arena::CreateMaybeMessage<::blickfeld::protocol::Field>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::Field_Identifier* Arena::CreateMaybeMessage<::blickfeld::protocol::Field_Identifier>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::HardwareModule* Arena::CreateMaybeMessage<::blickfeld::protocol::HardwareModule>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::OptionalValueRange* Arena::CreateMaybeMessage<::blickfeld::protocol::OptionalValueRange>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::SoftwareVersion* Arena::CreateMaybeMessage<::blickfeld::protocol::SoftwareVersion>(Arena*);
template<> BF_DLLEXPORT ::blickfeld::protocol::ValueRange* Arena::CreateMaybeMessage<::blickfeld::protocol::ValueRange>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace blickfeld {
namespace protocol {

enum Language : int {
  CPP = 1,
  PYTHON = 2,
  TYPESCRIPT = 3
};
BF_DLLEXPORT bool Language_IsValid(int value);
constexpr Language Language_MIN = CPP;
constexpr Language Language_MAX = TYPESCRIPT;
constexpr int Language_ARRAYSIZE = Language_MAX + 1;

BF_DLLEXPORT const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_descriptor();
template<typename T>
inline const std::string& Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Language_descriptor(), enum_t_value);
}
inline bool Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
// ===================================================================

class BF_DLLEXPORT ValueRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.ValueRange) */ {
 public:
  inline ValueRange() : ValueRange(nullptr) {}
  ~ValueRange() override;
  explicit constexpr ValueRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValueRange(const ValueRange& from);
  ValueRange(ValueRange&& from) noexcept
    : ValueRange() {
    *this = ::std::move(from);
  }

  inline ValueRange& operator=(const ValueRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueRange& operator=(ValueRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueRange* internal_default_instance() {
    return reinterpret_cast<const ValueRange*>(
               &_ValueRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ValueRange& a, ValueRange& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValueRange* New() const final {
    return CreateMaybeMessage<ValueRange>(nullptr);
  }

  ValueRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValueRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValueRange& from);
  void MergeFrom(const ValueRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.ValueRange";
  }
  protected:
  explicit ValueRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // optional float minimum = 1;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  float minimum() const;
  void set_minimum(float value);
  private:
  float _internal_minimum() const;
  void _internal_set_minimum(float value);
  public:

  // optional float maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  float maximum() const;
  void set_maximum(float value);
  private:
  float _internal_maximum() const;
  void _internal_set_maximum(float value);
  public:

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.ValueRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float minimum_;
  float maximum_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT OptionalValueRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.OptionalValueRange) */ {
 public:
  inline OptionalValueRange() : OptionalValueRange(nullptr) {}
  ~OptionalValueRange() override;
  explicit constexpr OptionalValueRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OptionalValueRange(const OptionalValueRange& from);
  OptionalValueRange(OptionalValueRange&& from) noexcept
    : OptionalValueRange() {
    *this = ::std::move(from);
  }

  inline OptionalValueRange& operator=(const OptionalValueRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionalValueRange& operator=(OptionalValueRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OptionalValueRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const OptionalValueRange* internal_default_instance() {
    return reinterpret_cast<const OptionalValueRange*>(
               &_OptionalValueRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OptionalValueRange& a, OptionalValueRange& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionalValueRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionalValueRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OptionalValueRange* New() const final {
    return CreateMaybeMessage<OptionalValueRange>(nullptr);
  }

  OptionalValueRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OptionalValueRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OptionalValueRange& from);
  void MergeFrom(const OptionalValueRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionalValueRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.OptionalValueRange";
  }
  protected:
  explicit OptionalValueRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // optional float minimum = 1 [(.blickfeld.protocol.optional) = true];
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  float minimum() const;
  void set_minimum(float value);
  private:
  float _internal_minimum() const;
  void _internal_set_minimum(float value);
  public:

  // optional float maximum = 2 [(.blickfeld.protocol.optional) = true];
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  float maximum() const;
  void set_maximum(float value);
  private:
  float _internal_maximum() const;
  void _internal_set_maximum(float value);
  public:

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.OptionalValueRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float minimum_;
  float maximum_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT SoftwareVersion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.SoftwareVersion) */ {
 public:
  inline SoftwareVersion() : SoftwareVersion(nullptr) {}
  ~SoftwareVersion() override;
  explicit constexpr SoftwareVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoftwareVersion(const SoftwareVersion& from);
  SoftwareVersion(SoftwareVersion&& from) noexcept
    : SoftwareVersion() {
    *this = ::std::move(from);
  }

  inline SoftwareVersion& operator=(const SoftwareVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareVersion& operator=(SoftwareVersion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftwareVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftwareVersion* internal_default_instance() {
    return reinterpret_cast<const SoftwareVersion*>(
               &_SoftwareVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SoftwareVersion& a, SoftwareVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareVersion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoftwareVersion* New() const final {
    return CreateMaybeMessage<SoftwareVersion>(nullptr);
  }

  SoftwareVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoftwareVersion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SoftwareVersion& from);
  void MergeFrom(const SoftwareVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareVersion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.SoftwareVersion";
  }
  protected:
  explicit SoftwareVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRevisionFieldNumber = 2,
    kCiJobIdFieldNumber = 3,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string revision = 2 [(.blickfeld.protocol.optional) = true];
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  const std::string& revision() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_revision(ArgT0&& arg0, ArgT... args);
  std::string* mutable_revision();
  std::string* release_revision();
  void set_allocated_revision(std::string* revision);
  private:
  const std::string& _internal_revision() const;
  void _internal_set_revision(const std::string& value);
  std::string* _internal_mutable_revision();
  public:

  // optional uint32 ci_job_id = 3 [(.blickfeld.protocol.optional) = true];
  bool has_ci_job_id() const;
  private:
  bool _internal_has_ci_job_id() const;
  public:
  void clear_ci_job_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 ci_job_id() const;
  void set_ci_job_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ci_job_id() const;
  void _internal_set_ci_job_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.SoftwareVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ci_job_id_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT HardwareModule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.HardwareModule) */ {
 public:
  inline HardwareModule() : HardwareModule(nullptr) {}
  ~HardwareModule() override;
  explicit constexpr HardwareModule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HardwareModule(const HardwareModule& from);
  HardwareModule(HardwareModule&& from) noexcept
    : HardwareModule() {
    *this = ::std::move(from);
  }

  inline HardwareModule& operator=(const HardwareModule& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareModule& operator=(HardwareModule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareModule& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareModule* internal_default_instance() {
    return reinterpret_cast<const HardwareModule*>(
               &_HardwareModule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HardwareModule& a, HardwareModule& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareModule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareModule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HardwareModule* New() const final {
    return CreateMaybeMessage<HardwareModule>(nullptr);
  }

  HardwareModule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HardwareModule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HardwareModule& from);
  void MergeFrom(const HardwareModule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareModule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.HardwareModule";
  }
  protected:
  explicit HardwareModule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialNumberFieldNumber = 1,
    kLegacySerialNumberFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // optional string serial_number = 1 [(.blickfeld.protocol.regex) = "[A-Z2-7]{9}", (.blickfeld.protocol.optional) = true, (.blickfeld.protocol.legacy_field_id) = 2];
  bool has_serial_number() const;
  private:
  bool _internal_has_serial_number() const;
  public:
  void clear_serial_number();
  const std::string& serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial_number();
  std::string* release_serial_number();
  void set_allocated_serial_number(std::string* serial_number);
  private:
  const std::string& _internal_serial_number() const;
  void _internal_set_serial_number(const std::string& value);
  std::string* _internal_mutable_serial_number();
  public:

  // optional string legacy_serial_number = 2 [deprecated = true, (.blickfeld.protocol.optional) = true];
  PROTOBUF_DEPRECATED bool has_legacy_serial_number() const;
  private:
  bool _internal_has_legacy_serial_number() const;
  public:
  PROTOBUF_DEPRECATED void clear_legacy_serial_number();
  PROTOBUF_DEPRECATED const std::string& legacy_serial_number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_legacy_serial_number(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_legacy_serial_number();
  PROTOBUF_DEPRECATED std::string* release_legacy_serial_number();
  PROTOBUF_DEPRECATED void set_allocated_legacy_serial_number(std::string* legacy_serial_number);
  private:
  const std::string& _internal_legacy_serial_number() const;
  void _internal_set_legacy_serial_number(const std::string& value);
  std::string* _internal_mutable_legacy_serial_number();
  public:

  // optional string version = 3 [(.blickfeld.protocol.regex) = "v[0-9]+\\.[0-9]+\\.[0-9]+", (.blickfeld.protocol.optional) = true];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.HardwareModule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr legacy_serial_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT Field_Identifier PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.Field.Identifier) */ {
 public:
  inline Field_Identifier() : Field_Identifier(nullptr) {}
  ~Field_Identifier() override;
  explicit constexpr Field_Identifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Field_Identifier(const Field_Identifier& from);
  Field_Identifier(Field_Identifier&& from) noexcept
    : Field_Identifier() {
    *this = ::std::move(from);
  }

  inline Field_Identifier& operator=(const Field_Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field_Identifier& operator=(Field_Identifier&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field_Identifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const Field_Identifier* internal_default_instance() {
    return reinterpret_cast<const Field_Identifier*>(
               &_Field_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Field_Identifier& a, Field_Identifier& b) {
    a.Swap(&b);
  }
  inline void Swap(Field_Identifier* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field_Identifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Field_Identifier* New() const final {
    return CreateMaybeMessage<Field_Identifier>(nullptr);
  }

  Field_Identifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Field_Identifier>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Field_Identifier& from);
  void MergeFrom(const Field_Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field_Identifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.Field.Identifier";
  }
  protected:
  explicit Field_Identifier(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kCamelcaseKeyFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // optional string key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string camelcase_key = 3;
  bool has_camelcase_key() const;
  private:
  bool _internal_has_camelcase_key() const;
  public:
  void clear_camelcase_key();
  const std::string& camelcase_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camelcase_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camelcase_key();
  std::string* release_camelcase_key();
  void set_allocated_camelcase_key(std::string* camelcase_key);
  private:
  const std::string& _internal_camelcase_key() const;
  void _internal_set_camelcase_key(const std::string& value);
  std::string* _internal_mutable_camelcase_key();
  public:

  // optional uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.Field.Identifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camelcase_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT Field PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  ~Field() override;
  explicit constexpr Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Field(const Field& from);
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const final {
    return CreateMaybeMessage<Field>(nullptr);
  }

  Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.Field";
  }
  protected:
  explicit Field(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Field_Identifier Identifier;

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifiersFieldNumber = 1,
    kScaleFieldNumber = 2,
  };
  // repeated .blickfeld.protocol.Field.Identifier identifiers = 1;
  int identifiers_size() const;
  private:
  int _internal_identifiers_size() const;
  public:
  void clear_identifiers();
  ::blickfeld::protocol::Field_Identifier* mutable_identifiers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blickfeld::protocol::Field_Identifier >*
      mutable_identifiers();
  private:
  const ::blickfeld::protocol::Field_Identifier& _internal_identifiers(int index) const;
  ::blickfeld::protocol::Field_Identifier* _internal_add_identifiers();
  public:
  const ::blickfeld::protocol::Field_Identifier& identifiers(int index) const;
  ::blickfeld::protocol::Field_Identifier* add_identifiers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blickfeld::protocol::Field_Identifier >&
      identifiers() const;

  // optional float scale = 2;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  float scale() const;
  void set_scale(float value);
  private:
  float _internal_scale() const;
  void _internal_set_scale(float value);
  public:

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blickfeld::protocol::Field_Identifier > identifiers_;
  float scale_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT Constraint_Constant PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.Constraint.Constant) */ {
 public:
  inline Constraint_Constant() : Constraint_Constant(nullptr) {}
  ~Constraint_Constant() override;
  explicit constexpr Constraint_Constant(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Constraint_Constant(const Constraint_Constant& from);
  Constraint_Constant(Constraint_Constant&& from) noexcept
    : Constraint_Constant() {
    *this = ::std::move(from);
  }

  inline Constraint_Constant& operator=(const Constraint_Constant& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraint_Constant& operator=(Constraint_Constant&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Constraint_Constant& default_instance() {
    return *internal_default_instance();
  }
  static inline const Constraint_Constant* internal_default_instance() {
    return reinterpret_cast<const Constraint_Constant*>(
               &_Constraint_Constant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Constraint_Constant& a, Constraint_Constant& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraint_Constant* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constraint_Constant* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Constraint_Constant* New() const final {
    return CreateMaybeMessage<Constraint_Constant>(nullptr);
  }

  Constraint_Constant* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Constraint_Constant>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Constraint_Constant& from);
  void MergeFrom(const Constraint_Constant& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraint_Constant* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.Constraint.Constant";
  }
  protected:
  explicit Constraint_Constant(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // optional float minimum = 1 [(.blickfeld.protocol.optional) = true];
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  float minimum() const;
  void set_minimum(float value);
  private:
  float _internal_minimum() const;
  void _internal_set_minimum(float value);
  public:

  // optional float maximum = 2 [(.blickfeld.protocol.optional) = true];
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  float maximum() const;
  void set_maximum(float value);
  private:
  float _internal_maximum() const;
  void _internal_set_maximum(float value);
  public:

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.Constraint.Constant)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float minimum_;
  float maximum_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT Constraint_Polynomial PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.Constraint.Polynomial) */ {
 public:
  inline Constraint_Polynomial() : Constraint_Polynomial(nullptr) {}
  ~Constraint_Polynomial() override;
  explicit constexpr Constraint_Polynomial(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Constraint_Polynomial(const Constraint_Polynomial& from);
  Constraint_Polynomial(Constraint_Polynomial&& from) noexcept
    : Constraint_Polynomial() {
    *this = ::std::move(from);
  }

  inline Constraint_Polynomial& operator=(const Constraint_Polynomial& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraint_Polynomial& operator=(Constraint_Polynomial&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Constraint_Polynomial& default_instance() {
    return *internal_default_instance();
  }
  static inline const Constraint_Polynomial* internal_default_instance() {
    return reinterpret_cast<const Constraint_Polynomial*>(
               &_Constraint_Polynomial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Constraint_Polynomial& a, Constraint_Polynomial& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraint_Polynomial* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constraint_Polynomial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Constraint_Polynomial* New() const final {
    return CreateMaybeMessage<Constraint_Polynomial>(nullptr);
  }

  Constraint_Polynomial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Constraint_Polynomial>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Constraint_Polynomial& from);
  void MergeFrom(const Constraint_Polynomial& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraint_Polynomial* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.Constraint.Polynomial";
  }
  protected:
  explicit Constraint_Polynomial(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 2,
    kMaximumFieldNumber = 3,
    kReferenceFieldNumber = 1,
  };
  // repeated float minimum = 2;
  int minimum_size() const;
  private:
  int _internal_minimum_size() const;
  public:
  void clear_minimum();
  private:
  float _internal_minimum(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_minimum() const;
  void _internal_add_minimum(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_minimum();
  public:
  float minimum(int index) const;
  void set_minimum(int index, float value);
  void add_minimum(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      minimum() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_minimum();

  // repeated float maximum = 3;
  int maximum_size() const;
  private:
  int _internal_maximum_size() const;
  public:
  void clear_maximum();
  private:
  float _internal_maximum(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_maximum() const;
  void _internal_add_maximum(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_maximum();
  public:
  float maximum(int index) const;
  void set_maximum(int index, float value);
  void add_maximum(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      maximum() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_maximum();

  // optional .blickfeld.protocol.Field reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::blickfeld::protocol::Field& reference() const;
  ::blickfeld::protocol::Field* release_reference();
  ::blickfeld::protocol::Field* mutable_reference();
  void set_allocated_reference(::blickfeld::protocol::Field* reference);
  private:
  const ::blickfeld::protocol::Field& _internal_reference() const;
  ::blickfeld::protocol::Field* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::blickfeld::protocol::Field* reference);
  ::blickfeld::protocol::Field* unsafe_arena_release_reference();

  // @@protoc_insertion_point(class_scope:blickfeld.protocol.Constraint.Polynomial)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > minimum_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > maximum_;
  ::blickfeld::protocol::Field* reference_;
  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// -------------------------------------------------------------------

class BF_DLLEXPORT Constraint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:blickfeld.protocol.Constraint) */ {
 public:
  inline Constraint() : Constraint(nullptr) {}
  ~Constraint() override;
  explicit constexpr Constraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Constraint(const Constraint& from);
  Constraint(Constraint&& from) noexcept
    : Constraint() {
    *this = ::std::move(from);
  }

  inline Constraint& operator=(const Constraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Constraint& operator=(Constraint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Constraint& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kConstant = 10,
    kPolynomial = 11,
    TYPE_NOT_SET = 0,
  };

  static inline const Constraint* internal_default_instance() {
    return reinterpret_cast<const Constraint*>(
               &_Constraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Constraint& a, Constraint& b) {
    a.Swap(&b);
  }
  inline void Swap(Constraint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Constraint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Constraint* New() const final {
    return CreateMaybeMessage<Constraint>(nullptr);
  }

  Constraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Constraint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Constraint& from);
  void MergeFrom(const Constraint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Constraint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "blickfeld.protocol.Constraint";
  }
  protected:
  explicit Constraint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Constraint_Constant Constant;
  typedef Constraint_Polynomial Polynomial;

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kTargetFieldNumber = 1,
    kConstantFieldNumber = 10,
    kPolynomialFieldNumber = 11,
  };
  // optional string reason = 2;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional .blickfeld.protocol.Field target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::blickfeld::protocol::Field& target() const;
  ::blickfeld::protocol::Field* release_target();
  ::blickfeld::protocol::Field* mutable_target();
  void set_allocated_target(::blickfeld::protocol::Field* target);
  private:
  const ::blickfeld::protocol::Field& _internal_target() const;
  ::blickfeld::protocol::Field* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::blickfeld::protocol::Field* target);
  ::blickfeld::protocol::Field* unsafe_arena_release_target();

  // .blickfeld.protocol.Constraint.Constant constant = 10;
  bool has_constant() const;
  private:
  bool _internal_has_constant() const;
  public:
  void clear_constant();
  const ::blickfeld::protocol::Constraint_Constant& constant() const;
  ::blickfeld::protocol::Constraint_Constant* release_constant();
  ::blickfeld::protocol::Constraint_Constant* mutable_constant();
  void set_allocated_constant(::blickfeld::protocol::Constraint_Constant* constant);
  private:
  const ::blickfeld::protocol::Constraint_Constant& _internal_constant() const;
  ::blickfeld::protocol::Constraint_Constant* _internal_mutable_constant();
  public:
  void unsafe_arena_set_allocated_constant(
      ::blickfeld::protocol::Constraint_Constant* constant);
  ::blickfeld::protocol::Constraint_Constant* unsafe_arena_release_constant();

  // .blickfeld.protocol.Constraint.Polynomial polynomial = 11;
  bool has_polynomial() const;
  private:
  bool _internal_has_polynomial() const;
  public:
  void clear_polynomial();
  const ::blickfeld::protocol::Constraint_Polynomial& polynomial() const;
  ::blickfeld::protocol::Constraint_Polynomial* release_polynomial();
  ::blickfeld::protocol::Constraint_Polynomial* mutable_polynomial();
  void set_allocated_polynomial(::blickfeld::protocol::Constraint_Polynomial* polynomial);
  private:
  const ::blickfeld::protocol::Constraint_Polynomial& _internal_polynomial() const;
  ::blickfeld::protocol::Constraint_Polynomial* _internal_mutable_polynomial();
  public:
  void unsafe_arena_set_allocated_polynomial(
      ::blickfeld::protocol::Constraint_Polynomial* polynomial);
  ::blickfeld::protocol::Constraint_Polynomial* unsafe_arena_release_polynomial();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:blickfeld.protocol.Constraint)
 private:
  class _Internal;
  void set_has_constant();
  void set_has_polynomial();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::blickfeld::protocol::Field* target_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::blickfeld::protocol::Constraint_Constant* constant_;
    ::blickfeld::protocol::Constraint_Polynomial* polynomial_;
  } type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_blickfeld_2fcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ValueRange

// optional float minimum = 1;
inline bool ValueRange::_internal_has_minimum() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ValueRange::has_minimum() const {
  return _internal_has_minimum();
}
inline void ValueRange::clear_minimum() {
  minimum_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ValueRange::_internal_minimum() const {
  return minimum_;
}
inline float ValueRange::minimum() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.ValueRange.minimum)
  return _internal_minimum();
}
inline void ValueRange::_internal_set_minimum(float value) {
  _has_bits_[0] |= 0x00000001u;
  minimum_ = value;
}
inline void ValueRange::set_minimum(float value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.ValueRange.minimum)
}

// optional float maximum = 2;
inline bool ValueRange::_internal_has_maximum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ValueRange::has_maximum() const {
  return _internal_has_maximum();
}
inline void ValueRange::clear_maximum() {
  maximum_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ValueRange::_internal_maximum() const {
  return maximum_;
}
inline float ValueRange::maximum() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.ValueRange.maximum)
  return _internal_maximum();
}
inline void ValueRange::_internal_set_maximum(float value) {
  _has_bits_[0] |= 0x00000002u;
  maximum_ = value;
}
inline void ValueRange::set_maximum(float value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.ValueRange.maximum)
}

// -------------------------------------------------------------------

// OptionalValueRange

// optional float minimum = 1 [(.blickfeld.protocol.optional) = true];
inline bool OptionalValueRange::_internal_has_minimum() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OptionalValueRange::has_minimum() const {
  return _internal_has_minimum();
}
inline void OptionalValueRange::clear_minimum() {
  minimum_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float OptionalValueRange::_internal_minimum() const {
  return minimum_;
}
inline float OptionalValueRange::minimum() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.OptionalValueRange.minimum)
  return _internal_minimum();
}
inline void OptionalValueRange::_internal_set_minimum(float value) {
  _has_bits_[0] |= 0x00000001u;
  minimum_ = value;
}
inline void OptionalValueRange::set_minimum(float value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.OptionalValueRange.minimum)
}

// optional float maximum = 2 [(.blickfeld.protocol.optional) = true];
inline bool OptionalValueRange::_internal_has_maximum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OptionalValueRange::has_maximum() const {
  return _internal_has_maximum();
}
inline void OptionalValueRange::clear_maximum() {
  maximum_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float OptionalValueRange::_internal_maximum() const {
  return maximum_;
}
inline float OptionalValueRange::maximum() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.OptionalValueRange.maximum)
  return _internal_maximum();
}
inline void OptionalValueRange::_internal_set_maximum(float value) {
  _has_bits_[0] |= 0x00000002u;
  maximum_ = value;
}
inline void OptionalValueRange::set_maximum(float value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.OptionalValueRange.maximum)
}

// -------------------------------------------------------------------

// SoftwareVersion

// optional string name = 1;
inline bool SoftwareVersion::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SoftwareVersion::has_name() const {
  return _internal_has_name();
}
inline void SoftwareVersion::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SoftwareVersion::name() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.SoftwareVersion.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void SoftwareVersion::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.SoftwareVersion.name)
}
inline std::string* SoftwareVersion::mutable_name() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.SoftwareVersion.name)
  return _internal_mutable_name();
}
inline const std::string& SoftwareVersion::_internal_name() const {
  return name_.Get();
}
inline void SoftwareVersion::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* SoftwareVersion::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SoftwareVersion::release_name() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.SoftwareVersion.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SoftwareVersion::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.SoftwareVersion.name)
}

// optional string revision = 2 [(.blickfeld.protocol.optional) = true];
inline bool SoftwareVersion::_internal_has_revision() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SoftwareVersion::has_revision() const {
  return _internal_has_revision();
}
inline void SoftwareVersion::clear_revision() {
  revision_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SoftwareVersion::revision() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.SoftwareVersion.revision)
  return _internal_revision();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void SoftwareVersion::set_revision(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.SoftwareVersion.revision)
}
inline std::string* SoftwareVersion::mutable_revision() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.SoftwareVersion.revision)
  return _internal_mutable_revision();
}
inline const std::string& SoftwareVersion::_internal_revision() const {
  return revision_.Get();
}
inline void SoftwareVersion::_internal_set_revision(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  revision_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* SoftwareVersion::_internal_mutable_revision() {
  _has_bits_[0] |= 0x00000002u;
  return revision_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SoftwareVersion::release_revision() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.SoftwareVersion.revision)
  if (!_internal_has_revision()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return revision_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SoftwareVersion::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  revision_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), revision,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.SoftwareVersion.revision)
}

// optional uint32 ci_job_id = 3 [(.blickfeld.protocol.optional) = true];
inline bool SoftwareVersion::_internal_has_ci_job_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SoftwareVersion::has_ci_job_id() const {
  return _internal_has_ci_job_id();
}
inline void SoftwareVersion::clear_ci_job_id() {
  ci_job_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SoftwareVersion::_internal_ci_job_id() const {
  return ci_job_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SoftwareVersion::ci_job_id() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.SoftwareVersion.ci_job_id)
  return _internal_ci_job_id();
}
inline void SoftwareVersion::_internal_set_ci_job_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  ci_job_id_ = value;
}
inline void SoftwareVersion::set_ci_job_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ci_job_id(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.SoftwareVersion.ci_job_id)
}

// -------------------------------------------------------------------

// HardwareModule

// optional string serial_number = 1 [(.blickfeld.protocol.regex) = "[A-Z2-7]{9}", (.blickfeld.protocol.optional) = true, (.blickfeld.protocol.legacy_field_id) = 2];
inline bool HardwareModule::_internal_has_serial_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HardwareModule::has_serial_number() const {
  return _internal_has_serial_number();
}
inline void HardwareModule::clear_serial_number() {
  serial_number_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HardwareModule::serial_number() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.HardwareModule.serial_number)
  return _internal_serial_number();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void HardwareModule::set_serial_number(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.HardwareModule.serial_number)
}
inline std::string* HardwareModule::mutable_serial_number() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.HardwareModule.serial_number)
  return _internal_mutable_serial_number();
}
inline const std::string& HardwareModule::_internal_serial_number() const {
  return serial_number_.Get();
}
inline void HardwareModule::_internal_set_serial_number(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* HardwareModule::_internal_mutable_serial_number() {
  _has_bits_[0] |= 0x00000001u;
  return serial_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HardwareModule::release_serial_number() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.HardwareModule.serial_number)
  if (!_internal_has_serial_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return serial_number_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HardwareModule::set_allocated_serial_number(std::string* serial_number) {
  if (serial_number != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serial_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial_number,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.HardwareModule.serial_number)
}

// optional string legacy_serial_number = 2 [deprecated = true, (.blickfeld.protocol.optional) = true];
inline bool HardwareModule::_internal_has_legacy_serial_number() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HardwareModule::has_legacy_serial_number() const {
  return _internal_has_legacy_serial_number();
}
inline void HardwareModule::clear_legacy_serial_number() {
  legacy_serial_number_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HardwareModule::legacy_serial_number() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.HardwareModule.legacy_serial_number)
  return _internal_legacy_serial_number();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void HardwareModule::set_legacy_serial_number(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 legacy_serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.HardwareModule.legacy_serial_number)
}
inline std::string* HardwareModule::mutable_legacy_serial_number() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.HardwareModule.legacy_serial_number)
  return _internal_mutable_legacy_serial_number();
}
inline const std::string& HardwareModule::_internal_legacy_serial_number() const {
  return legacy_serial_number_.Get();
}
inline void HardwareModule::_internal_set_legacy_serial_number(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  legacy_serial_number_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* HardwareModule::_internal_mutable_legacy_serial_number() {
  _has_bits_[0] |= 0x00000002u;
  return legacy_serial_number_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HardwareModule::release_legacy_serial_number() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.HardwareModule.legacy_serial_number)
  if (!_internal_has_legacy_serial_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return legacy_serial_number_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HardwareModule::set_allocated_legacy_serial_number(std::string* legacy_serial_number) {
  if (legacy_serial_number != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  legacy_serial_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), legacy_serial_number,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.HardwareModule.legacy_serial_number)
}

// optional string version = 3 [(.blickfeld.protocol.regex) = "v[0-9]+\\.[0-9]+\\.[0-9]+", (.blickfeld.protocol.optional) = true];
inline bool HardwareModule::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HardwareModule::has_version() const {
  return _internal_has_version();
}
inline void HardwareModule::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& HardwareModule::version() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.HardwareModule.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void HardwareModule::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.HardwareModule.version)
}
inline std::string* HardwareModule::mutable_version() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.HardwareModule.version)
  return _internal_mutable_version();
}
inline const std::string& HardwareModule::_internal_version() const {
  return version_.Get();
}
inline void HardwareModule::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* HardwareModule::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HardwareModule::release_version() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.HardwareModule.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HardwareModule::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.HardwareModule.version)
}

// -------------------------------------------------------------------

// Field_Identifier

// optional uint32 id = 1;
inline bool Field_Identifier::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Field_Identifier::has_id() const {
  return _internal_has_id();
}
inline void Field_Identifier::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Field_Identifier::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Field_Identifier::id() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Field.Identifier.id)
  return _internal_id();
}
inline void Field_Identifier::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void Field_Identifier::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Field.Identifier.id)
}

// optional string key = 2;
inline bool Field_Identifier::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Field_Identifier::has_key() const {
  return _internal_has_key();
}
inline void Field_Identifier::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Field_Identifier::key() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Field.Identifier.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Field_Identifier::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Field.Identifier.key)
}
inline std::string* Field_Identifier::mutable_key() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Field.Identifier.key)
  return _internal_mutable_key();
}
inline const std::string& Field_Identifier::_internal_key() const {
  return key_.Get();
}
inline void Field_Identifier::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Field_Identifier::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Field_Identifier::release_key() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.Field.Identifier.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Field_Identifier::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.Field.Identifier.key)
}

// optional string camelcase_key = 3;
inline bool Field_Identifier::_internal_has_camelcase_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Field_Identifier::has_camelcase_key() const {
  return _internal_has_camelcase_key();
}
inline void Field_Identifier::clear_camelcase_key() {
  camelcase_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Field_Identifier::camelcase_key() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Field.Identifier.camelcase_key)
  return _internal_camelcase_key();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Field_Identifier::set_camelcase_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 camelcase_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Field.Identifier.camelcase_key)
}
inline std::string* Field_Identifier::mutable_camelcase_key() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Field.Identifier.camelcase_key)
  return _internal_mutable_camelcase_key();
}
inline const std::string& Field_Identifier::_internal_camelcase_key() const {
  return camelcase_key_.Get();
}
inline void Field_Identifier::_internal_set_camelcase_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  camelcase_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Field_Identifier::_internal_mutable_camelcase_key() {
  _has_bits_[0] |= 0x00000002u;
  return camelcase_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Field_Identifier::release_camelcase_key() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.Field.Identifier.camelcase_key)
  if (!_internal_has_camelcase_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return camelcase_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Field_Identifier::set_allocated_camelcase_key(std::string* camelcase_key) {
  if (camelcase_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  camelcase_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), camelcase_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.Field.Identifier.camelcase_key)
}

// -------------------------------------------------------------------

// Field

// repeated .blickfeld.protocol.Field.Identifier identifiers = 1;
inline int Field::_internal_identifiers_size() const {
  return identifiers_.size();
}
inline int Field::identifiers_size() const {
  return _internal_identifiers_size();
}
inline void Field::clear_identifiers() {
  identifiers_.Clear();
}
inline ::blickfeld::protocol::Field_Identifier* Field::mutable_identifiers(int index) {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Field.identifiers)
  return identifiers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blickfeld::protocol::Field_Identifier >*
Field::mutable_identifiers() {
  // @@protoc_insertion_point(field_mutable_list:blickfeld.protocol.Field.identifiers)
  return &identifiers_;
}
inline const ::blickfeld::protocol::Field_Identifier& Field::_internal_identifiers(int index) const {
  return identifiers_.Get(index);
}
inline const ::blickfeld::protocol::Field_Identifier& Field::identifiers(int index) const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Field.identifiers)
  return _internal_identifiers(index);
}
inline ::blickfeld::protocol::Field_Identifier* Field::_internal_add_identifiers() {
  return identifiers_.Add();
}
inline ::blickfeld::protocol::Field_Identifier* Field::add_identifiers() {
  // @@protoc_insertion_point(field_add:blickfeld.protocol.Field.identifiers)
  return _internal_add_identifiers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::blickfeld::protocol::Field_Identifier >&
Field::identifiers() const {
  // @@protoc_insertion_point(field_list:blickfeld.protocol.Field.identifiers)
  return identifiers_;
}

// optional float scale = 2;
inline bool Field::_internal_has_scale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Field::has_scale() const {
  return _internal_has_scale();
}
inline void Field::clear_scale() {
  scale_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Field::_internal_scale() const {
  return scale_;
}
inline float Field::scale() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Field.scale)
  return _internal_scale();
}
inline void Field::_internal_set_scale(float value) {
  _has_bits_[0] |= 0x00000001u;
  scale_ = value;
}
inline void Field::set_scale(float value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Field.scale)
}

// -------------------------------------------------------------------

// Constraint_Constant

// optional float minimum = 1 [(.blickfeld.protocol.optional) = true];
inline bool Constraint_Constant::_internal_has_minimum() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Constraint_Constant::has_minimum() const {
  return _internal_has_minimum();
}
inline void Constraint_Constant::clear_minimum() {
  minimum_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Constraint_Constant::_internal_minimum() const {
  return minimum_;
}
inline float Constraint_Constant::minimum() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.Constant.minimum)
  return _internal_minimum();
}
inline void Constraint_Constant::_internal_set_minimum(float value) {
  _has_bits_[0] |= 0x00000001u;
  minimum_ = value;
}
inline void Constraint_Constant::set_minimum(float value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Constraint.Constant.minimum)
}

// optional float maximum = 2 [(.blickfeld.protocol.optional) = true];
inline bool Constraint_Constant::_internal_has_maximum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Constraint_Constant::has_maximum() const {
  return _internal_has_maximum();
}
inline void Constraint_Constant::clear_maximum() {
  maximum_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Constraint_Constant::_internal_maximum() const {
  return maximum_;
}
inline float Constraint_Constant::maximum() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.Constant.maximum)
  return _internal_maximum();
}
inline void Constraint_Constant::_internal_set_maximum(float value) {
  _has_bits_[0] |= 0x00000002u;
  maximum_ = value;
}
inline void Constraint_Constant::set_maximum(float value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Constraint.Constant.maximum)
}

// -------------------------------------------------------------------

// Constraint_Polynomial

// optional .blickfeld.protocol.Field reference = 1;
inline bool Constraint_Polynomial::_internal_has_reference() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || reference_ != nullptr);
  return value;
}
inline bool Constraint_Polynomial::has_reference() const {
  return _internal_has_reference();
}
inline void Constraint_Polynomial::clear_reference() {
  if (reference_ != nullptr) reference_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::blickfeld::protocol::Field& Constraint_Polynomial::_internal_reference() const {
  const ::blickfeld::protocol::Field* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::blickfeld::protocol::Field&>(
      ::blickfeld::protocol::_Field_default_instance_);
}
inline const ::blickfeld::protocol::Field& Constraint_Polynomial::reference() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.Polynomial.reference)
  return _internal_reference();
}
inline void Constraint_Polynomial::unsafe_arena_set_allocated_reference(
    ::blickfeld::protocol::Field* reference) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blickfeld.protocol.Constraint.Polynomial.reference)
}
inline ::blickfeld::protocol::Field* Constraint_Polynomial::release_reference() {
  _has_bits_[0] &= ~0x00000001u;
  ::blickfeld::protocol::Field* temp = reference_;
  reference_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::blickfeld::protocol::Field* Constraint_Polynomial::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.Constraint.Polynomial.reference)
  _has_bits_[0] &= ~0x00000001u;
  ::blickfeld::protocol::Field* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::blickfeld::protocol::Field* Constraint_Polynomial::_internal_mutable_reference() {
  _has_bits_[0] |= 0x00000001u;
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::blickfeld::protocol::Field>(GetArena());
    reference_ = p;
  }
  return reference_;
}
inline ::blickfeld::protocol::Field* Constraint_Polynomial::mutable_reference() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Constraint.Polynomial.reference)
  return _internal_mutable_reference();
}
inline void Constraint_Polynomial::set_allocated_reference(::blickfeld::protocol::Field* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.Constraint.Polynomial.reference)
}

// repeated float minimum = 2;
inline int Constraint_Polynomial::_internal_minimum_size() const {
  return minimum_.size();
}
inline int Constraint_Polynomial::minimum_size() const {
  return _internal_minimum_size();
}
inline void Constraint_Polynomial::clear_minimum() {
  minimum_.Clear();
}
inline float Constraint_Polynomial::_internal_minimum(int index) const {
  return minimum_.Get(index);
}
inline float Constraint_Polynomial::minimum(int index) const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.Polynomial.minimum)
  return _internal_minimum(index);
}
inline void Constraint_Polynomial::set_minimum(int index, float value) {
  minimum_.Set(index, value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Constraint.Polynomial.minimum)
}
inline void Constraint_Polynomial::_internal_add_minimum(float value) {
  minimum_.Add(value);
}
inline void Constraint_Polynomial::add_minimum(float value) {
  _internal_add_minimum(value);
  // @@protoc_insertion_point(field_add:blickfeld.protocol.Constraint.Polynomial.minimum)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Constraint_Polynomial::_internal_minimum() const {
  return minimum_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Constraint_Polynomial::minimum() const {
  // @@protoc_insertion_point(field_list:blickfeld.protocol.Constraint.Polynomial.minimum)
  return _internal_minimum();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Constraint_Polynomial::_internal_mutable_minimum() {
  return &minimum_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Constraint_Polynomial::mutable_minimum() {
  // @@protoc_insertion_point(field_mutable_list:blickfeld.protocol.Constraint.Polynomial.minimum)
  return _internal_mutable_minimum();
}

// repeated float maximum = 3;
inline int Constraint_Polynomial::_internal_maximum_size() const {
  return maximum_.size();
}
inline int Constraint_Polynomial::maximum_size() const {
  return _internal_maximum_size();
}
inline void Constraint_Polynomial::clear_maximum() {
  maximum_.Clear();
}
inline float Constraint_Polynomial::_internal_maximum(int index) const {
  return maximum_.Get(index);
}
inline float Constraint_Polynomial::maximum(int index) const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.Polynomial.maximum)
  return _internal_maximum(index);
}
inline void Constraint_Polynomial::set_maximum(int index, float value) {
  maximum_.Set(index, value);
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Constraint.Polynomial.maximum)
}
inline void Constraint_Polynomial::_internal_add_maximum(float value) {
  maximum_.Add(value);
}
inline void Constraint_Polynomial::add_maximum(float value) {
  _internal_add_maximum(value);
  // @@protoc_insertion_point(field_add:blickfeld.protocol.Constraint.Polynomial.maximum)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Constraint_Polynomial::_internal_maximum() const {
  return maximum_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Constraint_Polynomial::maximum() const {
  // @@protoc_insertion_point(field_list:blickfeld.protocol.Constraint.Polynomial.maximum)
  return _internal_maximum();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Constraint_Polynomial::_internal_mutable_maximum() {
  return &maximum_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Constraint_Polynomial::mutable_maximum() {
  // @@protoc_insertion_point(field_mutable_list:blickfeld.protocol.Constraint.Polynomial.maximum)
  return _internal_mutable_maximum();
}

// -------------------------------------------------------------------

// Constraint

// optional .blickfeld.protocol.Field target = 1;
inline bool Constraint::_internal_has_target() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || target_ != nullptr);
  return value;
}
inline bool Constraint::has_target() const {
  return _internal_has_target();
}
inline void Constraint::clear_target() {
  if (target_ != nullptr) target_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::blickfeld::protocol::Field& Constraint::_internal_target() const {
  const ::blickfeld::protocol::Field* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::blickfeld::protocol::Field&>(
      ::blickfeld::protocol::_Field_default_instance_);
}
inline const ::blickfeld::protocol::Field& Constraint::target() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.target)
  return _internal_target();
}
inline void Constraint::unsafe_arena_set_allocated_target(
    ::blickfeld::protocol::Field* target) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blickfeld.protocol.Constraint.target)
}
inline ::blickfeld::protocol::Field* Constraint::release_target() {
  _has_bits_[0] &= ~0x00000002u;
  ::blickfeld::protocol::Field* temp = target_;
  target_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::blickfeld::protocol::Field* Constraint::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.Constraint.target)
  _has_bits_[0] &= ~0x00000002u;
  ::blickfeld::protocol::Field* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::blickfeld::protocol::Field* Constraint::_internal_mutable_target() {
  _has_bits_[0] |= 0x00000002u;
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::blickfeld::protocol::Field>(GetArena());
    target_ = p;
  }
  return target_;
}
inline ::blickfeld::protocol::Field* Constraint::mutable_target() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Constraint.target)
  return _internal_mutable_target();
}
inline void Constraint::set_allocated_target(::blickfeld::protocol::Field* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.Constraint.target)
}

// optional string reason = 2;
inline bool Constraint::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Constraint::has_reason() const {
  return _internal_has_reason();
}
inline void Constraint::clear_reason() {
  reason_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Constraint::reason() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Constraint::set_reason(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:blickfeld.protocol.Constraint.reason)
}
inline std::string* Constraint::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Constraint.reason)
  return _internal_mutable_reason();
}
inline const std::string& Constraint::_internal_reason() const {
  return reason_.Get();
}
inline void Constraint::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Constraint::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Constraint::release_reason() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.Constraint.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Constraint::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:blickfeld.protocol.Constraint.reason)
}

// .blickfeld.protocol.Constraint.Constant constant = 10;
inline bool Constraint::_internal_has_constant() const {
  return type_case() == kConstant;
}
inline bool Constraint::has_constant() const {
  return _internal_has_constant();
}
inline void Constraint::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void Constraint::clear_constant() {
  if (_internal_has_constant()) {
    if (GetArena() == nullptr) {
      delete type_.constant_;
    }
    clear_has_type();
  }
}
inline ::blickfeld::protocol::Constraint_Constant* Constraint::release_constant() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.Constraint.constant)
  if (_internal_has_constant()) {
    clear_has_type();
      ::blickfeld::protocol::Constraint_Constant* temp = type_.constant_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blickfeld::protocol::Constraint_Constant& Constraint::_internal_constant() const {
  return _internal_has_constant()
      ? *type_.constant_
      : reinterpret_cast< ::blickfeld::protocol::Constraint_Constant&>(::blickfeld::protocol::_Constraint_Constant_default_instance_);
}
inline const ::blickfeld::protocol::Constraint_Constant& Constraint::constant() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.constant)
  return _internal_constant();
}
inline ::blickfeld::protocol::Constraint_Constant* Constraint::unsafe_arena_release_constant() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blickfeld.protocol.Constraint.constant)
  if (_internal_has_constant()) {
    clear_has_type();
    ::blickfeld::protocol::Constraint_Constant* temp = type_.constant_;
    type_.constant_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Constraint::unsafe_arena_set_allocated_constant(::blickfeld::protocol::Constraint_Constant* constant) {
  clear_type();
  if (constant) {
    set_has_constant();
    type_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blickfeld.protocol.Constraint.constant)
}
inline ::blickfeld::protocol::Constraint_Constant* Constraint::_internal_mutable_constant() {
  if (!_internal_has_constant()) {
    clear_type();
    set_has_constant();
    type_.constant_ = CreateMaybeMessage< ::blickfeld::protocol::Constraint_Constant >(GetArena());
  }
  return type_.constant_;
}
inline ::blickfeld::protocol::Constraint_Constant* Constraint::mutable_constant() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Constraint.constant)
  return _internal_mutable_constant();
}

// .blickfeld.protocol.Constraint.Polynomial polynomial = 11;
inline bool Constraint::_internal_has_polynomial() const {
  return type_case() == kPolynomial;
}
inline bool Constraint::has_polynomial() const {
  return _internal_has_polynomial();
}
inline void Constraint::set_has_polynomial() {
  _oneof_case_[0] = kPolynomial;
}
inline void Constraint::clear_polynomial() {
  if (_internal_has_polynomial()) {
    if (GetArena() == nullptr) {
      delete type_.polynomial_;
    }
    clear_has_type();
  }
}
inline ::blickfeld::protocol::Constraint_Polynomial* Constraint::release_polynomial() {
  // @@protoc_insertion_point(field_release:blickfeld.protocol.Constraint.polynomial)
  if (_internal_has_polynomial()) {
    clear_has_type();
      ::blickfeld::protocol::Constraint_Polynomial* temp = type_.polynomial_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.polynomial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::blickfeld::protocol::Constraint_Polynomial& Constraint::_internal_polynomial() const {
  return _internal_has_polynomial()
      ? *type_.polynomial_
      : reinterpret_cast< ::blickfeld::protocol::Constraint_Polynomial&>(::blickfeld::protocol::_Constraint_Polynomial_default_instance_);
}
inline const ::blickfeld::protocol::Constraint_Polynomial& Constraint::polynomial() const {
  // @@protoc_insertion_point(field_get:blickfeld.protocol.Constraint.polynomial)
  return _internal_polynomial();
}
inline ::blickfeld::protocol::Constraint_Polynomial* Constraint::unsafe_arena_release_polynomial() {
  // @@protoc_insertion_point(field_unsafe_arena_release:blickfeld.protocol.Constraint.polynomial)
  if (_internal_has_polynomial()) {
    clear_has_type();
    ::blickfeld::protocol::Constraint_Polynomial* temp = type_.polynomial_;
    type_.polynomial_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Constraint::unsafe_arena_set_allocated_polynomial(::blickfeld::protocol::Constraint_Polynomial* polynomial) {
  clear_type();
  if (polynomial) {
    set_has_polynomial();
    type_.polynomial_ = polynomial;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:blickfeld.protocol.Constraint.polynomial)
}
inline ::blickfeld::protocol::Constraint_Polynomial* Constraint::_internal_mutable_polynomial() {
  if (!_internal_has_polynomial()) {
    clear_type();
    set_has_polynomial();
    type_.polynomial_ = CreateMaybeMessage< ::blickfeld::protocol::Constraint_Polynomial >(GetArena());
  }
  return type_.polynomial_;
}
inline ::blickfeld::protocol::Constraint_Polynomial* Constraint::mutable_polynomial() {
  // @@protoc_insertion_point(field_mutable:blickfeld.protocol.Constraint.polynomial)
  return _internal_mutable_polynomial();
}

inline bool Constraint::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Constraint::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Constraint::TypeCase Constraint::type_case() const {
  return Constraint::TypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace blickfeld

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::blickfeld::protocol::Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::blickfeld::protocol::Language>() {
  return ::blickfeld::protocol::Language_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_blickfeld_2fcommon_2eproto
